-- WBDoc Baseball Live Scoring Schema Migration
-- This migration extends the existing schema to support real-time live scoring
-- with event logging, undo/edit capabilities, and umpire management
--
-- IMPORTANT: This migration uses a clean schema approach:
-- 1. Clean Schema: Removes redundant columns (event_type, event_data) in favor of (type, payload)
-- 2. RLS Policy Updates: Ensures consistent public read access across all tables
-- 3. Pre-launch Optimization: Since we're pre-launch, prioritizes simplicity over backward compatibility
--
-- DEVELOPMENT MODE: Currently configured for easy testing/dogfooding
-- - All write operations are open (no authentication required)
-- - Read operations are public for viewers
-- 
-- PRODUCTION SETUP: Before going live, you'll need to:
-- 1. Set up Supabase authentication (email, OAuth, etc.)
-- 2. Replace development RLS policies with production policies (see commented sections)
-- 3. Test authentication flow with umpire roles

-- Clean up the game_events table schema for live scoring
-- Since we're pre-launch, we can simplify rather than maintain backward compatibility

-- First, migrate any existing data to new column structure
DO $$
BEGIN
  -- Add new columns if they don't exist
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'game_events' AND column_name = 'umpire_id') THEN
    ALTER TABLE game_events ADD COLUMN umpire_id uuid REFERENCES players(id);
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'game_events' AND column_name = 'previous_event_id') THEN
    ALTER TABLE game_events ADD COLUMN previous_event_id uuid REFERENCES game_events(id);
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'game_events' AND column_name = 'type') THEN
    ALTER TABLE game_events ADD COLUMN type text;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'game_events' AND column_name = 'payload') THEN
    ALTER TABLE game_events ADD COLUMN payload jsonb;
  END IF;
  
  -- Migrate existing data if old columns exist
  IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'game_events' AND column_name = 'event_type') THEN
    UPDATE game_events SET type = event_type WHERE type IS NULL;
    UPDATE game_events SET payload = event_data WHERE payload IS NULL;
  END IF;
END $$;

-- Drop old columns entirely (clean schema)
ALTER TABLE game_events DROP COLUMN IF EXISTS event_type;
ALTER TABLE game_events DROP COLUMN IF EXISTS event_data;
ALTER TABLE game_events DROP COLUMN IF EXISTS at_bat_id; -- This was from old schema, not needed in live scoring
ALTER TABLE game_events DROP COLUMN IF EXISTS sequence_number; -- Will be auto-generated by trigger

-- Add sequence_number back as auto-generated column
ALTER TABLE game_events ADD COLUMN IF NOT EXISTS sequence_number integer;

-- Handle sequence_number properly for existing data
DO $$
BEGIN
  -- If there are existing events, populate sequence numbers
  IF EXISTS (SELECT 1 FROM game_events WHERE sequence_number IS NULL) THEN
    WITH numbered_events AS (
      SELECT id, ROW_NUMBER() OVER (PARTITION BY game_id ORDER BY created_at) as new_seq
      FROM game_events
    )
    UPDATE game_events 
    SET sequence_number = numbered_events.new_seq
    FROM numbered_events 
    WHERE game_events.id = numbered_events.id;
  END IF;
END $$;

-- Set proper constraints on the clean schema
ALTER TABLE game_events ALTER COLUMN type SET NOT NULL;
ALTER TABLE game_events ALTER COLUMN sequence_number SET NOT NULL;
ALTER TABLE game_events ADD CONSTRAINT game_events_type_check 
  CHECK (type IN ('pitch', 'flip_cup', 'at_bat', 'undo', 'edit', 'takeover', 'game_start', 'game_end'));

-- Add timestamp column with proper default and constraint
ALTER TABLE game_events ALTER COLUMN created_at SET DEFAULT now();
ALTER TABLE game_events ALTER COLUMN created_at SET NOT NULL;

-- Rename game_states to game_snapshots and modify structure to match PRD
-- First create the new game_snapshots table with PRD structure
CREATE TABLE IF NOT EXISTS game_snapshots (
  game_id uuid PRIMARY KEY REFERENCES games(id) ON DELETE CASCADE,
  current_inning integer NOT NULL DEFAULT 1,
  is_top_of_inning boolean NOT NULL DEFAULT true,
  outs integer NOT NULL DEFAULT 0 CHECK (outs >= 0 AND outs <= 3),
  balls integer NOT NULL DEFAULT 0 CHECK (balls >= 0 AND balls <= 4),
  strikes integer NOT NULL DEFAULT 0 CHECK (strikes >= 0 AND strikes <= 3),
  score_home integer NOT NULL DEFAULT 0,
  score_away integer NOT NULL DEFAULT 0,
  home_team_id uuid NOT NULL REFERENCES teams(id),
  away_team_id uuid NOT NULL REFERENCES teams(id),
  batter_id uuid REFERENCES players(id),
  catcher_id uuid REFERENCES players(id),
  base_runners jsonb DEFAULT '{"first": null, "second": null, "third": null}',
  home_lineup uuid[] DEFAULT '{}', -- Array of player IDs in batting order
  away_lineup uuid[] DEFAULT '{}', -- Array of player IDs in batting order  
  home_lineup_position integer DEFAULT 0 CHECK (home_lineup_position >= 0), -- Current batter index (0-based)
  away_lineup_position integer DEFAULT 0 CHECK (away_lineup_position >= 0), -- Current batter index (0-based)
  last_event_id uuid REFERENCES game_events(id),
  umpire_id uuid REFERENCES players(id),
  status text NOT NULL DEFAULT 'not_started' CHECK (status IN ('not_started', 'in_progress', 'paused', 'completed')),
  last_updated timestamptz NOT NULL DEFAULT now()
);

-- Migrate data from game_states to game_snapshots if game_states exists
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'game_states') THEN
    INSERT INTO game_snapshots (
      game_id, current_inning, is_top_of_inning, outs, balls, strikes,
      score_home, score_away, home_team_id, away_team_id, 
      batter_id, catcher_id, base_runners, last_updated
    )
    SELECT 
      gs.game_id,
      COALESCE(g.current_inning, 1),
      COALESCE(g.is_top_inning, true),
      COALESCE(gs.outs, 0),
      COALESCE(gs.balls, 0),
      COALESCE(gs.strikes, 0),
      COALESCE(g.home_score, 0),
      COALESCE(g.away_score, 0),
      g.home_team_id,
      g.away_team_id,
      gs.current_batter_id,
      gs.current_catcher_id,
      jsonb_build_object(
        'first', gs.runner_on_first,
        'second', gs.runner_on_second,
        'third', gs.runner_on_third
      ),
      gs.updated_at
    FROM game_states gs
    JOIN games g ON gs.game_id = g.id
    ON CONFLICT (game_id) DO NOTHING;
  END IF;
END $$;

-- Create indexes for performance on game_events
CREATE INDEX IF NOT EXISTS idx_game_events_game_id_timestamp ON game_events(game_id, created_at);
CREATE INDEX IF NOT EXISTS idx_game_events_type ON game_events(type);
CREATE INDEX IF NOT EXISTS idx_game_events_umpire_id ON game_events(umpire_id);
CREATE INDEX IF NOT EXISTS idx_game_events_previous_event_id ON game_events(previous_event_id);

-- Create indexes for game_snapshots
CREATE INDEX IF NOT EXISTS idx_game_snapshots_status ON game_snapshots(status);
CREATE INDEX IF NOT EXISTS idx_game_snapshots_umpire_id ON game_snapshots(umpire_id);
CREATE INDEX IF NOT EXISTS idx_game_snapshots_last_updated ON game_snapshots(last_updated);

-- Enable Row Level Security on new/modified tables
ALTER TABLE game_snapshots ENABLE ROW LEVEL SECURITY;

-- RLS Policies for game_events (updated for live scoring)
-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Allow read access for authenticated users" ON game_events;
DROP POLICY IF EXISTS "Allow public read access" ON game_events;

-- Public read access for viewers (no auth required)
CREATE POLICY "Allow public read access" ON game_events 
  FOR SELECT USING (true);

-- DEVELOPMENT POLICIES: Allow all writes for testing/dogfooding
-- TODO: Replace with proper authentication policies before production
CREATE POLICY "Allow all writes during development" ON game_events 
  FOR INSERT WITH CHECK (true);

CREATE POLICY "Allow all updates during development" ON game_events 
  FOR UPDATE USING (true);

-- PRODUCTION POLICIES (commented out for now):
-- CREATE POLICY "Allow authenticated write access" ON game_events 
--   FOR INSERT WITH CHECK (auth.role() = 'authenticated');
-- CREATE POLICY "Allow authenticated update access" ON game_events 
--   FOR UPDATE USING (true);

-- RLS Policies for game_snapshots
-- Public read access for viewers
CREATE POLICY "Allow public read access" ON game_snapshots 
  FOR SELECT USING (true);

-- DEVELOPMENT POLICIES: Allow all writes for testing/dogfooding
-- TODO: Replace with proper authentication policies before production
CREATE POLICY "Allow all writes during development" ON game_snapshots 
  FOR INSERT WITH CHECK (true);

CREATE POLICY "Allow all updates during development" ON game_snapshots 
  FOR UPDATE USING (true);

-- PRODUCTION POLICIES (commented out for now):
-- CREATE POLICY "Allow authenticated write access" ON game_snapshots 
--   FOR INSERT WITH CHECK (auth.role() = 'authenticated');
-- CREATE POLICY "Allow authenticated update access" ON game_snapshots 
--   FOR UPDATE USING (auth.role() = 'authenticated');

-- Enable real-time subscriptions on game_snapshots
ALTER PUBLICATION supabase_realtime ADD TABLE game_snapshots;

-- Add a function to automatically update game_snapshots.last_updated
CREATE OR REPLACE FUNCTION update_game_snapshot_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.last_updated = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to auto-update timestamp
DROP TRIGGER IF EXISTS trigger_update_game_snapshot_timestamp ON game_snapshots;
CREATE TRIGGER trigger_update_game_snapshot_timestamp
  BEFORE UPDATE ON game_snapshots
  FOR EACH ROW
  EXECUTE FUNCTION update_game_snapshot_timestamp();

-- Add a function to maintain sequence numbers within a game
CREATE OR REPLACE FUNCTION set_event_sequence_number()
RETURNS TRIGGER AS $$
BEGIN
  -- If sequence_number is not provided, calculate it
  IF NEW.sequence_number IS NULL THEN
    SELECT COALESCE(MAX(sequence_number), 0) + 1
    INTO NEW.sequence_number
    FROM game_events
    WHERE game_id = NEW.game_id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to auto-set sequence numbers
DROP TRIGGER IF EXISTS trigger_set_event_sequence_number ON game_events;
CREATE TRIGGER trigger_set_event_sequence_number
  BEFORE INSERT ON game_events
  FOR EACH ROW
  EXECUTE FUNCTION set_event_sequence_number();

-- Create a view for easy querying of current game states with team names
CREATE OR REPLACE VIEW live_game_status AS
SELECT 
  gs.game_id,
  gs.current_inning,
  gs.is_top_of_inning,
  gs.outs,
  gs.balls,
  gs.strikes,
  gs.score_home,
  gs.score_away,
  ht.name as home_team_name,
  ht.color as home_team_color,
  at.name as away_team_name,
  at.color as away_team_color,
  bp.name as batter_name,
  cp.name as catcher_name,
  gs.base_runners,
  up.name as umpire_name,
  gs.status,
  gs.last_updated,
  g.tournament_id,
  t.name as tournament_name
FROM game_snapshots gs
JOIN games g ON gs.game_id = g.id
JOIN teams ht ON gs.home_team_id = ht.id
JOIN teams at ON gs.away_team_id = at.id
LEFT JOIN players bp ON gs.batter_id = bp.id
LEFT JOIN players cp ON gs.catcher_id = cp.id
LEFT JOIN players up ON gs.umpire_id = up.id
LEFT JOIN tournaments t ON g.tournament_id = t.id;

-- Grant access to the view
GRANT SELECT ON live_game_status TO authenticated, anon;

-- Comments for documentation
COMMENT ON TABLE game_events IS 'Immutable event log for all game actions, supporting undo/edit and full audit trail';
COMMENT ON TABLE game_snapshots IS 'Current state of each game, updated synchronously with events for fast UI reads';
COMMENT ON COLUMN game_events.type IS 'Event type: pitch, flip_cup, at_bat, undo, edit, takeover, game_start, game_end';
COMMENT ON COLUMN game_events.payload IS 'Event-specific data in JSONB format';
COMMENT ON COLUMN game_events.previous_event_id IS 'Links to previous event for undo/edit functionality';
COMMENT ON COLUMN game_events.umpire_id IS 'Player who submitted this event';
COMMENT ON COLUMN game_snapshots.base_runners IS 'JSON object with first, second, third base runner player IDs';
COMMENT ON COLUMN game_snapshots.status IS 'Game status: not_started, in_progress, paused, completed'; 